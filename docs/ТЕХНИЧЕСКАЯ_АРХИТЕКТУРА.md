# Детальная техническая архитектура полностью автономной системы ИИ-агентов

## Цель документа

Этот документ описывает техническую архитектуру системы, где ИИ-агенты работают 24/7 без участия человека, автоматически генерируют задачи, пишут код, проверяют и исправляют ошибки. Документ предназначен для разработчика, который будет реализовывать систему.

## Общая архитектура системы

### Высокоуровневая схема

```
┌─────────────────────────────────────────────────────────────┐
│                    Облачный сервер                          │
│                  (AWS/GCP/Azure/VPS)                        │
└─────────────────────────────────────────────────────────────┘
                            │
        ┌───────────────────┼───────────────────┐
        │                   │                   │
┌───────▼────────┐  ┌──────▼──────┐  ┌────────▼────────┐
│ Docker         │  │ Git         │  │ LLM API         │
│ Container      │  │ Repository  │  │ (OpenAI/Claude) │
│ (агенты)       │  │ (код)       │  │                 │
└───────┬────────┘  └──────┬──────┘  └─────────────────┘
        │                  │
        └──────────────────┼──────────────────┐
                          │                  │
                  ┌───────▼────────┐  ┌──────▼──────┐
                  │ File System    │  │ CI/CD       │
                  │ (редактирование│  │ Pipeline    │
                  │  файлов)       │  │ (тесты,     │
                  └────────────────┘  │  деплой)    │
                                      └─────────────┘
```

### Компоненты системы

1. **Orchestrator** - координирует работу всех агентов
2. **Agent Pool** - пул агентов разных типов
3. **Task Queue** - очередь задач
4. **Memory System** - система памяти и контекста
5. **File System Manager** - управление файлами кода
6. **Git Manager** - операции с Git
7. **LLM Client** - клиент для работы с LLM API
8. **Test Runner** - запуск тестов
9. **Deployment Manager** - автоматический деплой

## Детальная архитектура компонентов

### 1. Orchestrator (Оркестратор задач)

#### Назначение
Координирует работу всех агентов, распределяет задачи, мониторит состояние системы.

#### Технические требования

**Основные функции:**
- Управление очередями задач для каждого агента
- Распределение задач между агентами
- Мониторинг статусов выполнения
- Эскалация проблем
- Непрерывный цикл генерации задач

**Структура данных:**

```python
# Псевдокод структуры
class TaskOrchestrator:
    - agent_queues: Dict[str, PriorityQueue]  # Очереди для каждого агента
    - active_tasks: Dict[str, TaskStatus]     # Активные задачи
    - task_results: Dict[str, TaskResult]      # Результаты выполнения
    - running: bool                            # Флаг работы
    - worker_threads: List[Thread]            # Потоки воркеров
```

**Алгоритм работы:**

1. **Инициализация:**
   - Создать очередь для каждого агента (PriorityQueue)
   - Запустить воркер-поток для каждого агента
   - Запустить главный цикл оркестратора

2. **Главный цикл (непрерывный):**
   ```
   WHILE running:
       - Проверить состояние системы
       - Если все задачи выполнены и нечем заняться:
           - CEO Agent генерирует новые задачи
           - Добавить задачи в очереди
       - Проверить зависшие задачи (timeout)
       - Обработать эскалации
       - Sleep(60 секунд)
   ```

3. **Воркер-поток агента:**
   ```
   WHILE running:
       - Получить задачу из очереди (timeout=1 сек)
       - Если задача есть:
           - Обновить статус: in_progress
           - Вызвать agent.process_task(task)
           - Сохранить результат
           - Если результат требует следующих агентов:
               - Создать новые задачи для следующих агентов
           - Обновить статус: completed/failed
   ```

4. **Распределение задач:**
   - Если задача уже содержит assigned_agents - использовать их
   - Если нет - определить агентов на основе типа задачи
   - Рассчитать приоритет задачи
   - Добавить в очереди соответствующих агентов

**Приоритет задач:**
- High priority: 1
- Medium priority: 5
- Low priority: 10
- С учетом дедлайна (если есть)

### 2. Agent System (Система агентов)

#### Базовый класс Agent

**Структура:**

```python
class BaseAgent:
    - name: str                    # Имя агента
    - role: str                    # Роль (CEO, CFO, Developer, etc.)
    - system_prompt: str           # Системный промпт
    - llm_client: LLMClient        # Клиент LLM
    - context_manager: ContextManager
    - memory_store: MemoryStore
    - active_tasks: List[str]       # Активные задачи
    - completed_tasks: List[str]    # Завершенные задачи
```

**Основные методы:**

1. **process_task(task) -> result:**
   - Получить контекст задачи
   - Вызвать LLM с промптом
   - Выполнить самопроверку (validate_result)
   - Если не валидно - исправить (макс 3 попытки)
   - После 3 попыток - смена подхода
   - Вернуть результат

2. **validate_result(result) -> validation:**
   - Создать промпт для проверки
   - Вызвать LLM для валидации
   - Вернуть: {valid: bool, score: float, issues: List[str]}

3. **generate_tasks() -> List[Task]:**
   - Проанализировать стратегию и текущее состояние
   - Сгенерировать новые задачи через LLM
   - Вернуть список задач

#### Специализированные агенты

**CEO Agent:**
- Генерирует задачи когда нечем заняться
- Принимает стратегические решения
- Приоритизирует задачи
- Делегирует задачи другим агентам

**CFO Agent:**
- Проверяет финансовые расчеты
- Оценивает финансовые риски
- Формирует финансовые вердикты
- Определяет критерии одобрения динамически

**Developer Agent:**
- Пишет код по TDD подходу
- Работает с файловой системой
- Интегрируется с Git
- Запускает тесты

**QA Agent:**
- Пишет тесты первыми (TDD)
- Определяет ограничения и требования
- Запускает тесты
- Анализирует результаты

**Risk Agent, Legal Agent, Security Agent:**
- Проверяют соответствующие аспекты
- Формируют вердикты
- Определяют критерии динамически

### 3. Memory System (Система памяти)

#### Компоненты

**MemoryStore (SQLite):**
- Таблица agent_memory: хранение долгосрочной памяти
- Таблица activity_logs: логи активности
- Таблица decision_history: история решений

**ContextManager:**
- agent_contexts: контекст каждого агента
- global_context: глобальный контекст (стратегия, цели)

**Структура БД:**

```sql
-- agent_memory
CREATE TABLE agent_memory (
    id INTEGER PRIMARY KEY,
    agent_name TEXT NOT NULL,
    key TEXT NOT NULL,
    value TEXT NOT NULL,  -- JSON
    created_at TIMESTAMP,
    updated_at TIMESTAMP,
    UNIQUE(agent_name, key)
);

-- activity_logs
CREATE TABLE activity_logs (
    id INTEGER PRIMARY KEY,
    agent_name TEXT NOT NULL,
    activity TEXT NOT NULL,
    details TEXT,  -- JSON
    timestamp TIMESTAMP
);

-- decision_history
CREATE TABLE decision_history (
    id INTEGER PRIMARY KEY,
    agent_name TEXT NOT NULL,
    decision_type TEXT NOT NULL,
    decision_data TEXT NOT NULL,  -- JSON
    timestamp TIMESTAMP
);
```

### 4. File System Manager (Управление файлами)

#### Назначение
Редактирование файлов кода напрямую через файловую систему.

#### Технические требования

**Основные функции:**
- Чтение файлов
- Запись файлов
- Создание файлов
- Удаление файлов
- Поиск файлов по паттерну
- Парсинг кода (AST для понимания структуры)

**Структура:**

```python
class FileSystemManager:
    - workspace_path: Path          # Путь к рабочей директории
    - git_repo_path: Path          # Путь к Git репозиторию
    
    def read_file(path) -> str
    def write_file(path, content) -> bool
    def create_file(path, content) -> bool
    def delete_file(path) -> bool
    def find_files(pattern) -> List[Path]
    def parse_code(path) -> AST
```

**Алгоритм редактирования кода:**

1. Прочитать существующий файл
2. Проанализировать структуру (AST)
3. Сгенерировать новый код через LLM
4. Записать файл
5. Проверить синтаксис (если возможно)
6. Commit в Git

### 5. Git Manager (Управление Git)

#### Назначение
Автоматические операции с Git: commit, push, pull, создание веток.

#### Технические требования

**Основные функции:**
- Git clone (при инициализации)
- Git add
- Git commit (с автоматическим сообщением)
- Git push
- Git pull
- Создание веток для фич
- Merge веток

**Структура:**

```python
class GitManager:
    - repo_path: Path
    - repo: git.Repo
    
    def clone(url, path) -> bool
    def add(files) -> bool
    def commit(message) -> bool
    def push(branch) -> bool
    def pull() -> bool
    def create_branch(name) -> bool
    def merge_branch(branch) -> bool
```

**Алгоритм работы:**

1. При инициализации: clone репозитория
2. При изменении файлов: add, commit, push
3. Commit message генерируется через LLM на основе изменений
4. Автоматический push в main или feature ветку

### 6. LLM Client (Клиент LLM)

#### Назначение
Абстракция для работы с разными LLM провайдерами.

#### Технические требования

**Поддерживаемые провайдеры:**
- OpenAI (GPT-4, GPT-3.5)
- Anthropic (Claude)

**Структура:**

```python
class LLMClient:
    def generate(prompt, temperature, max_tokens) -> str
    def generate_structured(prompt, schema) -> Dict
```

**Реализация для OpenAI:**
- Использовать openai Python library
- Chat completions API
- Поддержка structured output (JSON mode)

**Реализация для Anthropic:**
- Использовать anthropic Python library
- Messages API
- Поддержка structured output

**Кэширование:**
- Кэшировать одинаковые запросы
- Использовать hash промпта как ключ
- TTL кэша: 1 час

### 7. Test Runner (Запуск тестов)

#### Назначение
Автоматический запуск тестов после написания кода.

#### Технические требования

**Поддерживаемые фреймворки:**
- pytest (Python)
- jest (JavaScript/TypeScript)
- Другие через конфигурацию

**Структура:**

```python
class TestRunner:
    - test_framework: str           # pytest, jest, etc.
    - project_path: Path
    
    def run_tests() -> TestResult
    def run_specific_test(test_path) -> TestResult
    def parse_test_results() -> Dict
```

**Алгоритм:**

1. Определить фреймворк тестов (по конфигурации или автоопределение)
2. Запустить тесты через subprocess
3. Парсить вывод тестов
4. Вернуть структурированный результат:
   - passed: bool
   - failed: bool
   - test_count: int
   - failures: List[Dict]  # {test_name, error_message, traceback}

### 8. Deployment Manager (Деплой)

#### Назначение
Автоматический деплой после успешных тестов.

#### Технические требования

**Поддерживаемые платформы:**
- CI/CD через GitHub Actions / GitLab CI
- Прямой деплой на сервер
- Docker контейнеры

**Структура:**

```python
class DeploymentManager:
    - deployment_type: str          # ci_cd, direct, docker
    - config: Dict
    
    def deploy() -> bool
    def rollback() -> bool
    def check_status() -> DeploymentStatus
```

**Алгоритм:**

1. Если deployment_type == "ci_cd":
   - Просто push в Git, CI/CD сам задеплоит
2. Если deployment_type == "direct":
   - SSH на сервер
   - Pull изменений
   - Перезапустить сервис
3. Если deployment_type == "docker":
   - Build Docker image
   - Push в registry
   - Deploy на сервер

## Потоки данных

### Поток 1: Генерация и выполнение задачи

```
1. CEO Agent (главный цикл):
   - Проверяет: все задачи выполнены?
   - Если да - генерирует новые задачи через LLM
   - Отправляет в Orchestrator

2. Orchestrator:
   - Получает задачу
   - Определяет агентов для выполнения
   - Добавляет в очереди агентов

3. Agent Worker:
   - Получает задачу из очереди
   - Вызывает agent.process_task(task)
   - Агент выполняет задачу через LLM
   - Самопроверка (validate_result)
   - Если не валидно - исправление (макс 3 попытки)
   - После 3 попыток - смена подхода
   - Peer Review (другой агент)
   - Сохранение результата

4. Orchestrator:
   - Обновляет статус задачи
   - Если результат требует следующих агентов - создает новые задачи
```

### Поток 2: Написание кода (TDD)

```
1. Developer Agent получает задачу:
   - "Создать API endpoint /users"

2. QA Agent + Product Agent:
   - Определяют ограничения и требования
   - Пишут тесты ПЕРВЫМИ:
     * Unit тесты
     * Integration тесты
     * Ограничения (валидация, типы)

3. Developer Agent:
   - Читает тесты
   - Пишет код, который проходит тесты
   - Сохраняет файлы через FileSystemManager

4. Test Runner:
   - Запускает тесты
   - Парсит результаты

5. Если тесты не прошли:
   - Developer анализирует ошибки
   - Исправляет код (попытка 1)
   - Повторяет тесты
   - Если не прошли - попытка 2, 3
   - После 3 попыток - смена подхода

6. Если тесты прошли:
   - Code Review (Tech Lead Agent)
   - Если одобрено - Git commit/push
   - CI/CD автоматически деплоит
```

### Поток 3: Принятие решения

```
1. Product Agent генерирует идею:
   - "Добавить функцию X"

2. Orchestrator создает V-team:
   - Finance Agent
   - Risk Agent
   - Legal Agent
   - Tech Lead Agent

3. Параллельная работа:
   - Каждый агент анализирует идею
   - Определяет свои критерии одобрения (динамически)
   - Формирует вердикт

4. CEO Agent:
   - Собирает все вердикты
   - Анализирует критерии каждого агента
   - Принимает решение на основе контекста
   - Если одобрено - создает проект автоматически
```

## Технические детали реализации

### Непрерывный цикл CEO

**Алгоритм:**

```python
def ceo_continuous_loop():
    while running:
        # Проверить состояние
        active_tasks = orchestrator.get_active_tasks()
        pending_tasks = orchestrator.get_pending_tasks()
        
        # Если нет активных и pending задач
        if len(active_tasks) == 0 and len(pending_tasks) == 0:
            # Генерировать новые задачи
            new_tasks = ceo_agent.generate_tasks()
            for task in new_tasks:
                orchestrator.submit_task(task)
        
        # Ожидание
        sleep(60)  # Проверка каждую минуту
```

### Самокоррекция агента

**Алгоритм:**

```python
def process_task_with_self_correction(task):
    attempt = 0
    max_attempts = 3
    
    while attempt < max_attempts:
        # Выполнить задачу
        result = execute_task(task)
        
        # Самопроверка
        validation = validate_result(result)
        
        if validation['valid'] and validation['score'] >= 7.0:
            return result
        
        # Если не валидно - исправить
        if attempt < max_attempts - 1:
            result = fix_result(result, validation['issues'])
            attempt += 1
        else:
            # После 3 попыток - смена подхода
            result = change_approach(task, validation['issues'])
            attempt = 0  # Начать заново с новым подходом
    
    return result
```

### TDD подход для кода

**Алгоритм:**

```python
def write_code_tdd(task):
    # Шаг 1: Определить ограничения
    constraints = qa_agent.define_constraints(task)
    requirements = product_agent.define_requirements(task)
    
    # Шаг 2: Написать тесты ПЕРВЫМИ
    test_code = qa_agent.write_tests(task, constraints, requirements)
    test_file_path = file_manager.create_file(
        f"tests/test_{task['name']}.py",
        test_code
    )
    
    # Шаг 3: Написать код, который проходит тесты
    attempt = 0
    while attempt < 3:
        code = developer_agent.write_code(task, test_code)
        code_file_path = file_manager.create_file(
            task['file_path'],
            code
        )
        
        # Запустить тесты
        test_result = test_runner.run_tests(test_file_path)
        
        if test_result['passed']:
            break
        
        # Исправить код на основе ошибок
        code = developer_agent.fix_code(code, test_result['failures'])
        file_manager.write_file(code_file_path, code)
        attempt += 1
    
    # После 3 попыток - смена подхода
    if not test_result['passed']:
        # Полностью другой подход
        code = developer_agent.write_code_different_approach(
            task, test_code
        )
        file_manager.write_file(code_file_path, code)
        test_result = test_runner.run_tests(test_file_path)
    
    return code, test_result
```

### Динамические критерии одобрения

**Алгоритм:**

```python
def determine_approval_criteria(agent, task, context):
    prompt = f"""
    Ты {agent.role}. Тебе нужно определить критерии одобрения для задачи:
    
    Задача: {task['description']}
    Контекст проекта: {context['project']}
    Твоя роль: {agent.role}
    
    Определи критерии одобрения, которые важны для этой конкретной задачи.
    Будь гибким - критерии могут отличаться для разных задач.
    
    Верни критерии в формате:
    {{
        "criteria": [
            {{"name": "критерий1", "threshold": значение, "weight": важность}},
            ...
        ],
        "reasoning": "почему эти критерии"
    }}
    """
    
    response = llm_client.generate_structured(prompt, schema)
    return response['criteria']
```

## Конфигурация системы

### Структура конфигурации

```yaml
# config.yaml
llm:
  provider: "openai"  # или "anthropic"
  api_key: "${OPENAI_API_KEY}"
  model: "gpt-4"
  temperature: 0.7
  max_tokens: 2000

git:
  repository_url: "https://github.com/user/repo.git"
  branch: "main"
  auto_commit: true
  auto_push: true

file_system:
  workspace_path: "/workspace"
  git_repo_path: "/workspace/repo"

orchestrator:
  check_interval: 60  # секунды
  max_task_attempts: 3
  task_timeout: 3600  # секунды (1 час)

agents:
  ceo:
    temperature: 0.8
    max_tokens: 3000
  cfo:
    temperature: 0.5
    max_tokens: 2500
  developer:
    temperature: 0.7
    max_tokens: 2000

testing:
  framework: "pytest"  # или "jest"
  auto_run: true

deployment:
  type: "ci_cd"  # или "direct", "docker"
  ci_cd_provider: "github_actions"
```

## Деплой и инфраструктура

### Docker контейнер

**Dockerfile:**

```dockerfile
FROM python:3.11-slim

WORKDIR /app

# Установка зависимостей
COPY requirements.txt .
RUN pip install -r requirements.txt

# Копирование кода
COPY . .

# Запуск системы
CMD ["python", "main.py"]
```

**docker-compose.yml:**

```yaml
version: '3.8'

services:
  ai-agents:
    build: .
    environment:
      - OPENAI_API_KEY=${OPENAI_API_KEY}
      - GIT_REPO_URL=${GIT_REPO_URL}
    volumes:
      - ./workspace:/workspace
      - ./data:/app/data
      - ./logs:/app/logs
    restart: always
```

### Systemd service (Linux)

```ini
[Unit]
Description=AI Agents System
After=network.target

[Service]
Type=simple
User=ai-agents
WorkingDirectory=/app
ExecStart=/usr/bin/python3 /app/main.py
Restart=always
RestartSec=10

[Install]
WantedBy=multi-user.target
```

## Мониторинг и логирование

### Логирование
- Все действия агентов логируются
- Уровни: DEBUG, INFO, WARNING, ERROR
- Ротация логов (max 100MB, keep 7 days)
- Формат: JSON для парсинга

### Метрики
- Количество выполненных задач
- Время выполнения задач
- Процент успешных решений
- Количество ошибок
- Использование LLM API (запросы, токены, стоимость)

### Алерты
- Критические ошибки
- Зацикливание задач
- Превышение лимитов API
- Проблемы с Git

## Безопасность

### API ключи
- Хранить в переменных окружения
- Никогда не коммитить в Git
- Использовать секреты в CI/CD

### Доступ к файлам
- Ограничить права доступа
- Проверка перед записью критичных файлов
- Backup перед изменением

### Git операции
- Использовать отдельный токен для агентов
- Ограниченные права (только push в feature ветки)
- Code review для main ветки (через CI/CD)

## Масштабирование

### Горизонтальное масштабирование
- Несколько инстансов оркестратора
- Распределенная очередь задач (Redis)
- Общая база данных (PostgreSQL вместо SQLite)

### Вертикальное масштабирование
- Увеличение количества воркеров
- Параллельная обработка задач
- Кэширование LLM запросов

## Тестирование системы

### Unit тесты
- Тестирование каждого компонента отдельно
- Моки для LLM API
- Тестирование логики оркестратора

### Integration тесты
- Тестирование взаимодействия компонентов
- Тестирование потоков данных
- Тестирование Git операций

### E2E тесты
- Полный цикл: генерация задачи → выполнение → результат
- Тестирование TDD подхода
- Тестирование деплоя

## Документация для разработчика

### Структура проекта

```
ai-agents-system/
├── agents/              # Агенты
│   ├── base_agent.py
│   ├── ceo_agent.py
│   ├── cfo_agent.py
│   ├── developer_agent.py
│   └── qa_agent.py
├── orchestrator/        # Оркестратор
│   └── task_orchestrator.py
├── memory/              # Память
│   ├── memory_store.py
│   └── context_manager.py
├── file_system/         # Файловая система
│   └── file_manager.py
├── git/                 # Git
│   └── git_manager.py
├── llm/                 # LLM клиент
│   └── llm_client.py
├── testing/             # Тесты
│   └── test_runner.py
├── deployment/          # Деплой
│   └── deployment_manager.py
├── config/              # Конфигурация
│   └── settings.py
├── main.py              # Точка входа
└── requirements.txt     # Зависимости
```

### Зависимости

```
openai>=1.0.0
anthropic>=0.18.0
gitpython>=3.1.0
pydantic>=2.0.0
pyyaml>=6.0
```

## Критические моменты реализации

1. **Непрерывность**: Главный цикл должен работать всегда, даже при ошибках
2. **Обработка ошибок**: Все ошибки должны логироваться, система не должна падать
3. **Таймауты**: Все операции должны иметь таймауты
4. **Идемпотентность**: Операции должны быть безопасными при повторении
5. **Транзакционность**: Git операции должны быть атомарными

## Следующие шаги для разработчика

1. Начать с базовой структуры проекта
2. Реализовать LLM Client
3. Реализовать базовый Agent
4. Реализовать Orchestrator
5. Реализовать File System Manager
6. Реализовать Git Manager
7. Реализовать Test Runner
8. Интегрировать все компоненты
9. Тестирование
10. Деплой

